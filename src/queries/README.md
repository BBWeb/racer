Queries
=======

## Getting Started

```javascript
// Create queries using a query builder syntax.

var queryA = model.query('users').where('name').equals('Brian');
var queryB = model.query('users').byKey('some-uuid');
var queryC = model.query('blogs').where('authorId').equals(userId);
var queryD = model.query('items').where('tags').in(['derby', 'racer']);

// The code above only builds queries but does not run them. To run them,
// we pass the queries to `store.subscribe` and `store.fetch`

// This will subscribe a model to any results that match queryA, queryB,
// or queryC even if those result sets dynamically change over time. The
// developer need not worry about figuring out which documents to add or
// remove from the model. Racer will automatically figure this out and
// automatically add this to the model, updating any bindings in realtime.

model.subscribe(queryA, queryB, queryC, function (err, resA, resB, resC) {
  // Declare a ref, so we can bind results via private path '_resultsA'
  model.ref('_resultsA', resA); // `resA` is a model alias

  model.ref('_resultsB', resB); // `resB` is a model alias

  model.ref('_resultsC', resC); // `resC` is a model alias
});

// The following will fetch the results of queryD from the store but will
// not automatically keep those results dynamically up-to-date.

model.fetch(queryD, function (err, resD) {

  console.log(resD.get()); // log the results

});

// You can also query data already loaded into the browser, by invoking `find`
// on your query. Notice how the function signature has no asynchronous
// callback, but instead returns the results synchronously.

var resE = model.query('users').where('age').gte(25).find();

// resE will be a model alias.

console.log(resE.get());

// TODO This feature is desired but not yet implemented
  // In addition to returning a model alias of a result set, you can also have
  // the query subscribe to results of data that is not already loaded into the
  // page. This is useful when you can get immediate results to display based on
  // data already loaded into your model, instead of waiting for a subscribe
  // callback which is only invoked after a round trip to the server.

  var resE = model.query('users').where('age').gte(25).find();
  model.subscribe(resE);

// You can also scope your queries to results of another query
var queryF = model.query('users').where('age').gte(22);
model.subscribe(queryF, function (err, results) {
  var importantRacerItems = model.query(results).where('tags').contain(['priority', 'racer']);
});

// Queries can also work on arrays of documents that are pointed to by private
// or public paths.

```

## Architecture

- ModelQueryBuilder and QueryBuilder: A fluent interface to build query json objects.
- filter: Can test that a document satisfies a filter function generated by a
  query json object.
- MemoryQuery:
- QueryCoordinator:
- QueryHub
- QueryNode
- PaginatedQueryNode

## Query Security
