var QueryHub = require('./QueryHub')
  , QueryBuilder = require('./QueryBuilder')
  , path = require('../path')
  , splitPath = path.split
  , lookup = path.lookup
  , finishAfter = require('../util/async').finishAfter
  , queryUtils = require('./util')
  , resultPointerPath = queryUtils.resultPointerPath
  , QueryMotifRegistry = require('./QueryMotifRegistry')
  , createMiddleware = require('../middleware')
  ;

module.exports = {
  type: 'Store'

, events: {
    init: function (store, opts) {
      store._queryCoordinator = new QueryHub(store);

      // Contains registered query motifs defined via store.query.expose
      var registry = store._queryMotifRegistry = new QueryMotifRegistry;

      /**
       * Exposes a parameterized data set equivalent to the result set of a
       * query generated by the `callback`. The parameterized
       * Behind the scenes, this creates a QueryMotif.
       * Query motifs define a set of data equivalent to the result set of a
       * query, and they provide an easy string name reference to this data. This
       * declares and registers a query motif that will subsequently be available
       * from the Store or Model via Store#_queryMotifRegistry and
       * Model#_queryMotifRegistry respectively.
       *
       * @optional @param {String} ns is the namespace of documents over which to
       * query
       * @param {String} motifName is the name of the query motif
       * @param {Function} callback in which we define the query.
       * callback(queryArgs...) returns a QueryBuilder
       * @return {Object} store.query for method chaining
       * @api public
       */
      var chainable = store.query = {
        expose: function (ns, motifName, callback) {
          registry.add(ns, motifName, callback);
          return chainable;
        }
      };
    }
  , middleware: function (store, middleware) {
      var mode = store._mode;
      middleware.snapshot = createMiddleware()
      if (mode.startIdVerifier) {
        middleware.snapshot.add(mode.startIdVerifier);
      }
      middleware.snapshot.add( function (req, res, next) {
        var clientId = req.clientId;
        if (req.shouldSubscribe) {
          store._pubSub.subscribe(clientId, req.subs);
        }
        mode.snapshotSince({
          ver: req.ver
        , clientId: clientId
        , subs: req.subs
        }, function (err, payload) {
          if (err) return res.fail(err);
          var data = payload.data
            , txns = payload.txns
            , num = store._txnClock.nextTxnNum(clientId);
          if (data) {
            res.send('snapshotUpdate:replace', data, num);
          } else if (txns) {
            var len;
            if (len = txns.length) {
              socket.__ver = transaction.getVer(txns[len-1]);
            }
            res.send('snapshotUpdate:newTxns', txns, num);
          }
          next();
        });
      });

      middleware.fetch = createMiddleware()
      middleware.fetch.add(function (req, res, next) {
        var targets = req.targets
          , data = []
          , finish = finishAfter(targets.length, function (err) {
              if (err) return cb(err);
              var out = {data: data};
              self.emit('fetch', out, req.clientId, targets);
              res.send(out);
            })
          , session = req.session;
        for (var i = 0, l = targets.length; i < l; i++) {
          var target = targets[i];
          var _req = {
            target: target
          , clientId: req.clientId
          , session: req.session
          , context: req.context
          };
          var _res = {
            fail: function (err) {
              res.fail(err);
            }
          , send: function (doc) {
              data[i] = doc;
            }
          };
          var mware = ('string' === typeof target)
                    ? middleware.fetchPath
                    : middleware.fetchQuery;
          mware(_req, _res, finish);
        }
      });

      middleware.fetchPath = createMiddleware();
      middleware.fetchPath.add(function (req, res, next) {
        req.context.guardReadPath(req, res, next);
      });
      middleware.fetchPath.add(function (req, res, next) {
        var path = req.data;
        // TODO We need to pass back array of document ids to assign to
        //      queries.someid.resultIds
        store._fetchPathData(path, {
          each: function (path, datum, ver) {
            res.send([path, datum, ver]);
          }
        , done: next
        });
      });
    }
  , socket: function (store, socket, clientId) {
      socket.on('fetch', function (targets, contextName, cb) {
        var req = {
          targets: targets
        , clientId: socket.clientId
        , session: socket.session
        , context: store.context(contextName)
        };
        var res = {
          fail: function (err) {
            cb(err);
          }
        , send: function (data) {
            // For OT
            // Note that `data` may be mutated by ot or other plugins
            store.emit('fetch', data, clientId, targets);

            cb(null, data);
          }
        };
        store.middleware.fetch(req, res);
      });

      socket.on('fetch:snapshot', function (ver, clientStartId, subs) {
        store._onSnapshotRequest(ver, clientStartId, clientId, socket, subs);
      });
    }
  }

, proto: {
    /**
     * Fetches the data represented by targets. The callback is passed {data:
     * data} where data is an Array of triplets of the form [path, datum, ver]
     * meaning to assign datum at version ver to the path inside the fetching
     * model.
     *
     * @param {Socket} socket
     * @param {[String|[String, ...]]} targets is an array of strings and query
     * tuples representing paths, patterns, and/or query motifs.
     * @param {Function} cb is the callback
     * @api private
     */
    // TODO Incorporate contexts
    fetch: function (socket, targets, contextName, cb) {
      var data = []
        , self = this
        , finish = finishAfter(targets.length, function (err) {
            if (err) return cb(err);
            var out = {data: data};
            // Note that `out` may be mutated by ot or other plugins
            self.emit('fetch', out, socket.clientId, targets);
            cb(null, out);
          })
        , session = socket.session
        , context = this.context(contextName);
      for (var i = 0, l = targets.length; i < l; i++) {
        self._fetchSingle(context, session, targets[i], data, finish);
      }
    }

  /**
   * @param {Object} session of the client doing the fetching. The session is
   * used by _fetchSingle pre middleware for access control
   * @param {String|Array} target is a string representing a path or pattern.
   * Or it is an Array of [motifName, motifArgs...] representing a query motif.
   * @param {Array} data
   * @param {Function} callback
   * @api private
   */
 , _fetchSingle: function (context, session, target, data, callback) {
      var fetchFn = ('string' === typeof target)
                  ? this._fetchPathData
                  : this._fetchAndCompileQueryData; // Otherwise, we have an array
      // TODO We need to pass back array of document ids to assign to
      //      queries.someid.resultIds
      fetchFn.call(this, target, {
        context: context
      , session: session
      , each: function (path, datum, ver) {
          data.push([path, datum, ver]);
        }
      , done: callback
      });
    }

    /**
     * Fetches data associated with a queryTuple [ns, {queryMotif: queryArgs, ...}].
     *
     * @param {Array} queryTuple represented as
     * [ns, {queryMotif: queryArgs, ...}]
     * @param {Object} opts can have keys:
     *
     * - each: Function invoked for every matching document
     * - finish: Function invoked after the query results are fetched
     *   and after opts.each has been called on every matching document.
     * @api private
     */
  , _fetchAndCompileQueryData: function (queryTuple, opts) {
      var eachDatumCb = opts.each
        , finish = opts.done
        , queryJson = this._queryMotifRegistry.queryJSON(queryTuple)
        , queryId = queryTuple[queryTuple.length-1];
      this._fetchQueryData(queryTuple, function (err, result, version) {
        if (err) return finish(err);
        var path;
        if (Array.isArray(result)) {
          var resultIds = [];
          for (var i = 0, l = result.length; i < l; i++) {
            var doc = result[i];
            path = queryJson.from + '.' + doc.id;
            eachDatumCb(path, doc, version);
            resultIds.push(doc.id);
          }

          // '_$queries.<queryId>.resultIds'
          path = resultPointerPath(queryId, queryJson.type);
          eachDatumCb(path, resultIds, version);
        } else if (result) {
          path = queryJson.from + '.' + result.id;
          eachDatumCb(path, result, version);

          // '_$queries.<queryId>.resultId'
          path = resultPointerPath(queryId, queryJson.type);
          eachDatumCb(path, result.id, version);
        }
        finish(null);
      });
    }

    /**
     * @param {Array} queryTuple represented as [ns, queryMotif, params...]
     * @param {Function} callback(err, result, version)
     */
  , _fetchQueryData: function (queryTuple, callback) {
      var queryJson = this._queryMotifRegistry.queryJSON(queryTuple)
        , queryId = queryTuple[queryTuple.length-1];
      // TODO fetch(queryTuple, ...) ?
      this._queryCoordinator.fetch(queryJson, callback);
    }

    /**
     * Fetches data associated with a path in our data tree.
     *
     * @param {String} path to data that we want to fetch
     * @param {Object} opts can have keys:
     *
     * - each: Function invoked for every matching document
     * - finish: Function invoked after the query results are fetched
     *   and after opts.each has been called on every matching document.
     * @api private
     */
  , _fetchPathData: function (path, opts) {
      var eachDatumCb = opts.each
        , finish = opts.done
        , parts = splitPath(path)
        , root = parts[0]
        , remainder = parts[1];
      this.get(root, function (err, datum, ver) {
        if (err) return finish(err);
        if (typeof remainder === 'undefined') {
          eachDatumCb(path, datum, ver);
        } else {
          // The path looks like <root>.*.<remainder>
          // so set each property one level down
          patternMatchingDatum(root, remainder, datum, function (fullPath, datum) {
            eachDatumCb(fullPath, datum, ver);
          });
        }
        return finish(null);
      });
    }

    /**
     * @param {Number} ver is the version
     * @param {} clientStartId
     * @param {String} clientId
     * @param {Socket} socket
     * @param {Array} subs
     * @param {Boolean} shouldSubscribe
     * @api private
     */
  , _onSnapshotRequest: function (ver, clientStartId, clientId, socket, subs, shouldSubscribe) {
      var req = {
        startId: clientStartId
      , clientId: clientId
      , shouldSubscribe: shouldSubscribe
      , subs: subs
      , ver: ver
      };
      var res = {
        fail: function (err) {
          // TODO Should allow different kind of errors - e.g., "txnErr"
          socket.emit('fatalErr', err);
        }
      , send: function (channel, dataOrTxns, num) {
          socket.emit(channel, dataOrTxns, num);
        }
      };
      this.middleware.snapshot(req, res);
    }
  }
};

/**
 * @param {String} prefix is the part of the path up to ".*."
 * @param {String} remainder is the part of the path after ".*."
 * @param {Object} subDoc is the lookup value of the prefix
 * @param {Function} eachDatumCb is the callback for each datum matching the pattern
 * @api private
 */
function patternMatchingDatum (prefix, remainder, subDoc, eachDatumCb) {
  var parts          = splitPath(remainder)
    , appendToPrefix = parts[0]
    , remainder      = parts[1];
  for (var property in subDoc) {
    var value = subDoc[property];
    if (value.constructor !== Object && ! Array.isArray(value)) {
      // We can't lookup `appendToPrefix` on `value` in this case
      continue;
    }
    var newPrefix = prefix + '.' + property + '.' + appendToPrefix
      , newValue = lookup(appendToPrefix, value);
    if (typeof remainder === 'undefined') {
      eachDatumCb(newPrefix, newValue);
    } else {
      patternMatchingDatum(newPrefix, remainder, newValue, eachDatumCb);
    }
  }
}
