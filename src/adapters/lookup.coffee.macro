{create, createObject, createArray} = require '../specHelper'

module.exports =
  #for LOOKUP WITH_VERSION ADD_PATH SET_VERSION

  #if LOOKUP
  # Returns value
  # Used by getters & reference indexer
  # Does not dereference the final item if getRef is truthy
  lookup: (path, data, getRef) ->
  #end
  #if WITH_VERSION
  # Returns [value, {ver}]
  # Used by getters
  lookupWithVersion: (path, data, vers) ->
  #end
  #if ADD_PATH
  # Returns value
  # Used by reference indexer
  lookupAddPath: (path, data, speculative, pathType) ->
  #end
  #if SET_VERSION
  # Returns [value, {ver}, parent, prop]
  # Used by setters & delete
  lookupSetVersion: (path, data, vers, setVer, pathType) ->
    speculative = !setVer
  #end

    curr = data
    #if WITH_VERSION or SET_VERSION
    currVer = vers
    #end
    #if SET_VERSION
    currVer.ver = setVer  if setVer
    #end
    props = path.split '.'
    path = ''
    data.$remainder = ''
    i = 0
    len = props.length

    while i < len
      prop = props[i++]
      #if ADD_PATH or SET_VERSION
      parent = curr
      #end
      curr = curr[prop]

      #if WITH_VERSION
      currVer = currVer[prop] || currVer
      #elseif SET_VERSION
      currVer = currVer[prop] || if pathType && setVer then currVer[prop] = {} else currVer
      #end

      # The absolute path traversed so far
      path = if path then path + '.' + prop else prop

      #if ADD_PATH or SET_VERSION
      # Create empty objects implied by the path
      if curr?
        curr = parent[prop] = create curr  if speculative && typeof curr is 'object'
      else
        unless pathType
          data.$remainder = props.slice(i).join '.'
          break
        # If pathType is truthy, create empty parent objects implied by path
        curr = parent[prop] = if speculative
            if pathType is 'array' && i == len then createArray() else createObject()
          else
            if pathType is 'array' && i == len then [] else {}
      #else
      break unless curr?
      #end

      if curr.$r
        #if LOOKUP
        break if getRef && i == len
        #end

        #if WITH_VERSION
        [refObj, currVer] = lookupWithVersion curr.$r, data, vers
        #elseif SET_VERSION
        [refObj, currVer] = lookupSetVersion curr.$r, data, vers, setVer, pathType
        #else
        refObj = lookup curr.$r, data
        #end
        dereffedPath = if data.$remainder then "#{data.$path}.#{data.$remainder}" else data.$path

        if key = curr.$k
          if Array.isArray keyObj = lookup key, data
            if i < len
              prop = keyObj[props[i++]]
              path = dereffedPath + '.' + prop
              #if WITH_VERSION
              [curr, currVer] = lookupWithVersion path, data, vers
              #elseif SET_VERSION
              [curr, currVer] = lookupSetVersion path, data, vers, setVer, pathType
              #else
              curr = lookup dereffedPath, data
              #end
            else
              curr = (lookup dereffedPath + '.' + index, data for index in keyObj)
          else
            dereffedPath += '.' + keyObj
            curr = lookup dereffedPath, data
            path = dereffedPath unless i == len
        else
          curr = refObj
          path = dereffedPath unless i == len
      
        #if ADD_PATH or SET_VERSION
        if `curr == null` && !pathType
        #else
        if `curr == null`
        #end
          # Return if the reference points to nothing
          data.$remainder = props.slice(i).join '.'
          break

      else
        currVer.ver = setVer  if setVer

    data.$path = path
    #if SET_VERSION
    return [curr, currVer, parent, prop]
    #elseif WITH_VERSION
    return [curr, currVer]
    #else
    return curr
    #end
  #end
